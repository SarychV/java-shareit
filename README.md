# java-shareit
Сервис для шеринга (от англ. share — «делиться») вещей.

## Используемые технологии, инструменты, библиотеки

REST API, Java, Spring Boot, Spring Data JPA, Lombok, JUnit5, Mockito, SQL, Apache Maven, Docker

## Общие сведения

Шеринг как экономика совместного использования набирает сейчас всё большую полярность. Если в 2014 году глобальный 
рынок шеринга оценивался всего в $15 млрд, то к 2025 может достигнуть $335 млрд. Почему шеринг так популярен. 

Представьте, что на вы купили несколько картин и хотите повесить их дома. Но вот незадача — для этого нужна дрель, 
а её у вас нет. Можно, конечно, пойти в магазин и купить, но в такой покупке мало смысла: после того, как вы повесите 
картины, дрель будет просто пылиться в шкафу. Напрашивается идея — одолжить её. Большая удача, если у вашего
знакомого оказалась дрель и вы сразу вспомнили про него, а не занимались поисками инструмента. Но чаще, было 
бы удобнее, если бы под рукой был сервис, где другие люди предлагают воспользоваться своими вещами!

Приложение java-shareit представляет REST сервис, предназначенный чтобы обеспечить пользователям возможность 
рассказывать другим, какими вещами они готовы поделиться, а также находить нужную вещь и брать для себя её в аренду 
на какое-то время. Сервис не только позволяет бронировать вещь на определённые даты, но и закрывать к ней доступ 
на время бронирования от других желающих. На случай, если нужной вещи на сервисе нет, пользователи могут оставлять 
запросы. Вдруг древний граммофон, который странно даже предлагать к аренде, неожиданно понадобится, например, для 
театральной постановки. По такому запросу можно будет добавить новую вещь для шеринга.

Функционал программы реализован с использованием Spring Boot, который обеспечивает взаимодействие между 
REST-контроллерами, бизнес-логикой (сервисами) и хранилищами (репозиториями). Репозитории реализуют интерфейсы 
к СУБД. Доступ к данным реализован с использованием проекта Spring Data JPA.

Основная сущность сервиса — это вещь, которая предлагается для использования. В коде она представлена классом Item. 
Пользователь, который добавляет в приложение свою вещь, считается ее владельцем. При добавлении вещи имеется 
возможность указать её краткое название и добавить небольшое описание. К примеру, название может быть — «Дрель “Салют”»,
а описание — «Мощность 600 вт, работает ударный режим, так что бетон возьмёт». Также у вещи обязательно есть статус — 
доступна ли она для аренды. Статус проставляется владельцем.

Для нахождения вещей организован поиск. Чтобы воспользоваться нужной вещью, её требуется забронировать. Бронирование, 
или Booking — ещё одна важная сущность приложения. Бронируется вещь всегда на определённые даты. Владелец вещи 
обязательно должен подтвердить бронирование. После того как вещь возвращена, у пользователя, который её арендовал, 
имеется возможность оставить отзыв. В отзыве можно поблагодарить владельца вещи и подтвердить, что задача выполнена — 
дрель успешно справилась с бетоном, и картины размещены в требуемые места.

Ещё одна сущность приложения — это запрос вещи ItemRequest. Пользователь создаёт запрос, если нужная ему вещь 
не найдена при поиске. В запросе указывается, что именно он ищет. В ответ на запрос другие пользовали могут добавить 
нужную вещь.

## Реализация модели данных

В приложении использована структура не по типам классов, а по фичам (англ. Feature layout) — весь код для работы 
с определённой сущностью помещается в одном пакете. Созданы пакеты — item, booking, request и user, а также 
вспомогательные пакеты exception, validation. В пакетах размещены контроллеры, сервисы, репозитории и другие классы,
которые необходимы в работе.

Основу модели данных приложения составляют следующие классы:
- User, представляет пользователей, которые могут предлагать и использовать вещи для аренды;
- Item, собственно сами предлагаемые для аренды вещи;
- Booking, с использованием данного класса выполняется бронирование вещей;
- ItemRequest, класс для запроса вещи;
- Comment, позволяет создавать и обрабатывать комментарии пользователей после аренды вещей.

Обмен информацией через REST API выполняется с использованием объектов для передачи данных (DTO). Преобразование
объектов модели в DTO-объекты и обратно выполняется mapper-классами.

Для обработки запросов в соответсвующих пакетах созданы контроллеры: UserController, ItemController, 
BookingController, ItemRequestController. Для соответствующих контроллеров разработаны сервисные классы. Через 
сервисные классы (имена классов содержат слово Service) осуществляется обращения к классам, представляющим уровень 
доступа к данным - к JPA репозиториям (имена классов содержат слово Repository).

### Основные функции для работы с вещами

- Добавление новой вещи. Происходит по эндпойнту POST /items. На вход поступает объект ItemDto.  
    >userId, получаемый из заголовка X-Sharer-User-Id http-запроса — это идентификатор пользователя, который 
составил запрос к сервису. В программе это может быть владелец вещи, или пользователь который ищет необходимую ему 
вещь. Идентификатор пользователя поступает на вход большинства запросов, рассмотренных далее.

- Редактирование вещи. Эндпойнт PATCH /items/{itemId}. Изменить можно название, описание и статус доступа к аренде. 
Редактировать вещь может только её владелец. 
- Просмотр информации о конкретной вещи по её идентификатору. Эндпойнт GET /items/{itemId}. Информацию о вещи может 
просмотреть любой пользователь.
- Просмотр владельцем списка всех его вещей с указанием названия и описания для каждой. Эндпойнт GET /items.
- Поиск вещи потенциальным арендатором. Пользователь передаёт в строке запроса текст, и система ищет вещи, 
содержащие этот текст в названии или описании. Происходит по эндпойнту /items/search?text={text}, в text передаётся 
текст для поиска. Поиск возвращает только доступные для аренды вещи.
- Владелец видит даты последнего и ближайшего следующего бронирования для каждой вещи, когда просматривает список 
(GET /items).

### Функции бронирования

- Добавление нового запроса на бронирование. Запрос может быть создан любым пользователем, а затем подтверждён 
владельцем вещи. Эндпоинт — POST /bookings. После создания запрос находится в статусе WAITING — «ожидает подтверждения». 
- Подтверждение или отклонение запроса на бронирование. Выполняется только владельцем вещи. Затем статус бронирования 
становится либо APPROVED, либо REJECTED. Эндпоинт — PATCH /bookings/{bookingId}?approved={approved}, параметр approved 
может принимать значения true или false.
- Получение данных о конкретном бронировании (включая его статус). Доступно для автора бронирования, либо владельца 
вещи, к которой относится бронирование. Эндпоинт — GET /bookings/{bookingId}.
- Получение списка всех бронирований текущего пользователя. Эндпоинт — GET /bookings?state={state}. Параметр state 
необязательный и по умолчанию равен ALL (англ. «все»). Также он может принимать значения CURRENT (англ. «текущие»), 
PAST (англ. «завершённые»), FUTURE (англ. «будущие»), WAITING (англ. «ожидающие подтверждения»), REJECTED (англ. 
«отклонённые»). Ответы возвращаются отсортированными по дате от более новых бронирований к более старым.
- Получение списка бронирований для всех вещей текущего пользователя. Эндпоинт — GET /bookings/owner?state={state}. 
Этот запрос имеет смысл для владельца хотя бы одной вещи. Работа параметра state аналогична его работе в предыдущем 
сценарии.

### Работа с отзывами
 
- Комментарий можно добавить по эндпоинту POST /items/{itemId}/comment. Добавление нового комментария к вещи возможно
только после аренды вещи пользователем.
- Пользователям можно просматривать комментарии других пользователей. Отзывы можно увидеть по двум эндпоинтам — 
по GET /items/{itemId} для одной конкретной вещи и по GET /items для всех вещей данного пользователя.

## Описание базы данных

Объекты приложения отображаются на соответствующие таблицы базы данных. Для этого в файле schema.sql определены 
SQL-команды для создания следующих таблиц: users, items, bookings, requests, comments. Таблицы используют суррогатные 
ключи.

Между таблицами есть следущие связи. 

Пользователь может предлагать свои вещи (создавать о них записи в базе). Пользователь может быть владельцем 
нескольких вещей, поэтому связь между таблицами users и items - один-ко-многим. 

Пользователи могут арендовать несколько вещей. В свою очередь, вещь в разное время может быть арендована разными 
пользователями. Между этими сущностями имеется связь многие-ко-многим. Данная связь реализована через таблицу bookings, 
которая содержит информацию об аренде вещей пользователями. Таблица bookings преобразует связь многие-ко-многим между 
сущностями пользователь и вещь в две связи с типом многие-к-одному: с таблицей users и с таблицей items. 

Если нужная пользователю вещь отсутствует в базе, то можно создать запрос к другим пользователям с просьбой одолжить ее 
(у кого она есть). Пользователь может создавать разные запросы о разных вещах. Связь между сущностями пользователь и 
запрос вещи - один-ко-многим.

После завершения аренды пользователи могут оставлять комментарии об арендованных вещах. При этом пользователь может 
комментировать разные вещи, и одна вещь может комментироваться разными пользователями. Данная связь является 
многие-ко-многим. Реализована она через таблицу comments.

Связи между таблицами реализованы через внешние ключи.

## Использование контейнеров для работы приложения

Приложение реализовано с элементами микросервисной архитектуры. По сценарию, с целью разгрузки основного сервера, 
в сервисе gateway (модуль проекта gateway) выполняется валидация поступивших запросов. Если запрос проходит проверку, 
то он пересылается основному серверу, который реализован сервисом server (модуль проекта server). Http-клиент в сервисе 
gateway работает в синхронном режиме, т.е. он направляет серверу запросы и дожидается получения ответов на них. 
Для реализации клиента используется класс RestTemplate из состава Spring Framework. Основной функционал клиента 
реализован в классе BaseClient, который является родительским для других классов в модуле, используемых для 
взаимодействия с сервером (имена классов завершаются словом Client).

Для обеспечения загрузки программы в Docker-контейнерах подготовлены конфигурации в файлах docker-compose.yml 
(в корневом каталоге проекта) и Dockerfile (в соответствующих каталогах модулей). Для подготовки проекта к запуску 
необходимо:
1. Выполнить компиляцию исходного кода проекта, для чего, находясь в корневом каталоге проекта, следует
выполнить команду:  
`$ mvn clean package`
2. Также, находясь в корневом каталоге проекта, создать и запустить Docker-контейнеры с помощью команды:  
`$ docker compose up`  
В результате, загружены будут два Docker-контейнера, один для работы сервиса gateway, другой для работы сервиса server.

Команда `$ docker compose down` остановит работу запущенных Docker-контейнеров. 

## Тестирование

Одной из основных задач в данной работе была отработка использования средств тестирования в программе. Для тестирования 
приложения использовались postman-тесты (файл postman/sprint.json), модульные тесты и использованием JUnit5, а также 
интеграционное тестирование (использовалась библиотека Mockito). Тесты размещены в соответствующих для maven-проекта 
каталогах.
